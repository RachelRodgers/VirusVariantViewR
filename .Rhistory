}
}
return(sampleClassList)
}
sampleVector <- c("Baldridge_17", "Baldridge_16", "Baldridge_15")
dataSet <- "baldridge_rumspringa"
originalSampleObjectList <- BuildSampleObjects(dataSet = dataSet, sampleVector = sampleVector)
library("shiny")
library("shinythemes")
library("shinyjs")
library("DT")
library("Gviz")
library("data.table")
library("tidyverse")
# Genome Coverage Data #
# Read in genome coverage count data, calculate avg. genome coverage
rawFiles <- list.files(path = paste0("../", dataSet, "/sample_data/genome_coverage/"),
pattern = "*_coverage.txt")
# Read in and format VCF file for selected sample
variantSample <- paste0("../", dataSet, "/variants/annotated_variants/", sample, "_variants_annotated.txt")
GetVCF <- function(dataSet, sample) {
# Read in and format VCF file for selected sample
variantSample <- paste0("../", dataSet, "/variants/annotated_variants/", sample, "_variants_annotated.txt")
vcfFile <- data.table::fread(file = variantSample,
header = TRUE, sep = "\t",
stringsAsFactors = FALSE,
verbose = FALSE)
# Get the primary alignment value from the current sample's alignment counts
sampleAlignmentCounts <- GenerateSampleData(dataSet)
samplePrimaryAlignments <- subset(sampleAlignmentCounts,
Sample == sample)$`Primary Alignments`
# Filter sampleAlignmentCounts by sample
#samplePrimaryAlignments <- subset(GenerateSampleData,
#sample == sample)$primary_alignments
# The raw read depth at each position will be given by DP=xx; the first element
#   in the INFO field.  Will divide the allelic depth by this value to get
#   the allelic frequency.
# The last number in Values will be the allelic depth - unfiltered number of
#   reads supporting the reported allele(s)
vcfFileFormatted <- vcfFile %>%
mutate("Allelic Depth" = map_chr(.x = str_split(Values, pattern = ","),
.f = tail, n = 1),
"Total Depth" = str_remove(str_extract(Info, "DP=[:digit:]+"),
"DP="),
# Allelic Freq = (allelic depth/raw depth) * 100%
"Allelic Frequency (%)" =
round((100 * as.numeric(`Allelic Depth`)/as.numeric(`Total Depth`)),
digits = 2)) %>%
select(-c("ID", "Filter", "Info", "Format", "Values"))
comment(vcfFileFormatted) <- sample
return(vcfFileFormatted)
}
# Alignment Count Data #
GenerateSampleData <- function(dataSet) {
# Read in sample alignment count data, calculate percent MNV
readCounts <- read.delim(paste0("../", dataSet, "/alignment_counts.txt"))
readCounts <- readCounts %>%
mutate("percent_MNV" = round(100*(primary_alignments/total_reads),
digits = 2))
# Genome Coverage Data #
# Read in genome coverage count data, calculate avg. genome coverage
rawFiles <- list.files(path = paste0("../", dataSet, "/sample_data/genome_coverage/"),
pattern = "*_coverage.txt")
# column names determined from documentation at
# https://bedtools.readthedocs.io/en/latest/content/tools/genomecov.html
columnNames <- c("chromosome", "depth", "number_of_bases",
"chromosome_size", "fraction_of_bases")
# Run calculation, store in genomeCovVec - will be combined with readCounts
genomeCovVec <- vector(mode = "integer", length = length(rawFiles))
for (i in 1:length(rawFiles)) {
currentFile <- rawFiles[i]
currentFileName <- as.vector(strsplit(currentFile, "_coverage.txt")[[1]])
currentData <- read.delim(paste0("../", dataSet,
"/sample_data/genome_coverage/",
currentFile),
header = FALSE,
col.names = columnNames)
currentData <- currentData %>%
dplyr::select(depth, number_of_bases) %>%
dplyr::mutate(product = depth * number_of_bases)
avg_cov <- round(sum(currentData$product)/genome_size,
digits = 0)
genomeCovVec[i] <- avg_cov
names(genomeCovVec)[i] <- currentFileName
}
# Merge Data #
# Add the average genome coverage numbers to the readCounts data
sampleData <- readCounts %>%
dplyr::mutate("avg_genome_cov" = genomeCovVec[sample])
names(sampleData) <- c("Sample", "Total Reads", "Primary Alignments",
"% MNV", "Average Coverage")
sampleData$Sample <- as.character(sampleData$Sample)
return(sampleData)
}
FindExactMatches <- function(sampleObjectList) {
# Check if any samples have 0 variants and remove.
variantsAreNull <- vector(mode = "logical", length = length(sampleObjectList))
for (i in 1:length(sampleObjectList)) {
variantsAreNull[i]<- is.null(names(sampleObjectList[[i]]@variant_list))
}
selectedSampleObjectList <- sampleObjectList[!variantsAreNull]
#----- Exact Matching (Position & Variant) -----#
# For all the variants between the selected samples, make a table showing which
#   samples they are in.
sampleVariantsDFList <- vector(mode = "list", length = length(selectedSampleObjectList))
sampleVariantsPresenceList <- vector(mode = "list", length = length(selectedSampleObjectList))
# pull extra info here and stick into currentSampleDF
for (k in 1:length(selectedSampleObjectList)) {
# Get current sample information
currentSample <- selectedSampleObjectList[[k]]
currentSampleName <- currentSample@sample_name
# Build concatenated data frame from all the variants' variant_df slots
#   get current Variants, put in list
currentVariantList <- currentSample@variant_list
#   pull out each variant's variant_df, put in list
currentVariantDFList <- map(.x = seq(1:length(currentVariantList)),
.f = function(idx) currentVariantList[[idx]]@variant_df)
#   reduce the list into one big df - (all variants' info for one sample only)
combinedVariantDFs <- Reduce(f = function(df1, df2) {rbind(x = df1, y = df2)},
x = currentVariantDFList)
#   store the samples variants info in sampleVariantsDFList to be reduced later
sampleVariantsDFList[[k]] <- combinedVariantDFs
# Build variantPresenceDF that will be used for searching for common variants
variantPresenceDF <- data.frame(names(currentSample@variant_list), 1)
colnames(variantPresenceDF) <- c("variants", currentSampleName)
sampleVariantsPresenceList[[k]] <- variantPresenceDF
}
# Merge the presence data frames together, convert NA's to 0's
fullPresenceDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2,
by = "variants", all = TRUE)},
x = sampleVariantsPresenceList)
fullPresenceDF[is.na(fullPresenceDF)] <- 0
# remove extra columns before attempting rowSums
# What are the counts for each variant?
fullPresenceDFModified <- column_to_rownames(fullPresenceDF, var = "variants")
variantCounts <- rowSums(fullPresenceDFModified)
# Which samples do you find each variant in?
variantInSamples <- vector(mode = "character", length = nrow(fullPresenceDFModified))
for (m in 1:nrow(fullPresenceDFModified)) {
currentRow <- fullPresenceDFModified[m, ]
currentVariantName <- rownames(currentRow)
samplesVecString <- paste(colnames(currentRow)[currentRow != 0], collapse = ", ")
variantInSamples[m] <- samplesVecString
names(variantInSamples)[m] <- currentVariantName
}
# Change things to a DF merge
variantCountsDF <- data.frame("Number_of_Samples" = variantCounts)
variantInSamplesDF <- data.frame("Samples" = variantInSamples)
# Make sure the dimensions of these match
if (!(identical(dim(variantCountsDF), dim(variantInSamplesDF)))) {
stop("Something is wrong with the variant/sample counting.",
call. = FALSE)
}
# Otherwise, merge them.
variantDataDF <- merge(variantCountsDF, variantInSamplesDF, by = "row.names")
variantDataDF <- variantDataDF %>%
filter(Number_of_Samples >= 2) %>%
arrange(desc(Number_of_Samples)) %>%
column_to_rownames(var = "Row.names") %>%
rownames_to_column("Variation")
# Put warning within app.R to deal with empty table.
# Now pull extra information before displaying table - from Reducing information
#   from sampleVariantsDFList
variantInformationDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2, all = TRUE)},
x = sampleVariantsDFList)
# From variantInformationDF, append information to variantDataDF
variantInformationFullDF <- merge(x = variantDataDF, variantInformationDF,
by = "Variation", all = FALSE)
# Modify the table
variantInformationFinal <- variantInformationFullDF %>%
select(-c(Variation)) %>%
select(Variation_Readable, everything()) %>%
data.table::setnames(old = "Variation_Readable",
new = "Variation")
return(variantInformationFinal)
}
FindExactMatches <- function(sampleObjectList) {
# Check if any samples have 0 variants and remove.
variantsAreNull <- vector(mode = "logical", length = length(sampleObjectList))
for (i in 1:length(sampleObjectList)) {
variantsAreNull[i]<- is.null(names(sampleObjectList[[i]]@variant_list))
}
selectedSampleObjectList <- sampleObjectList[!variantsAreNull]
#----- Exact Matching (Position & Variant) -----#
# For all the variants between the selected samples, make a table showing which
#   samples they are in.
sampleVariantsDFList <- vector(mode = "list", length = length(selectedSampleObjectList))
sampleVariantsPresenceList <- vector(mode = "list", length = length(selectedSampleObjectList))
# pull extra info here and stick into currentSampleDF
for (k in 1:length(selectedSampleObjectList)) {
# Get current sample information
currentSample <- selectedSampleObjectList[[k]]
currentSampleName <- currentSample@sample_name
# Build concatenated data frame from all the variants' variant_df slots
#   get current Variants, put in list
currentVariantList <- currentSample@variant_list
#   pull out each variant's variant_df, put in list
currentVariantDFList <- map(.x = seq(1:length(currentVariantList)),
.f = function(idx) currentVariantList[[idx]]@variant_df)
#   reduce the list into one big df - (all variants' info for one sample only)
combinedVariantDFs <- Reduce(f = function(df1, df2) {rbind(x = df1, y = df2)},
x = currentVariantDFList)
#   store the samples variants info in sampleVariantsDFList to be reduced later
sampleVariantsDFList[[k]] <- combinedVariantDFs
# Build variantPresenceDF that will be used for searching for common variants
variantPresenceDF <- data.frame(names(currentSample@variant_list), 1)
colnames(variantPresenceDF) <- c("variants", currentSampleName)
sampleVariantsPresenceList[[k]] <- variantPresenceDF
}
# Merge the presence data frames together, convert NA's to 0's
fullPresenceDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2,
by = "variants", all = TRUE)},
x = sampleVariantsPresenceList)
fullPresenceDF[is.na(fullPresenceDF)] <- 0
# remove extra columns before attempting rowSums
# What are the counts for each variant?
fullPresenceDFModified <- column_to_rownames(fullPresenceDF, var = "variants")
variantCounts <- rowSums(fullPresenceDFModified)
# Which samples do you find each variant in?
variantInSamples <- vector(mode = "character", length = nrow(fullPresenceDFModified))
for (m in 1:nrow(fullPresenceDFModified)) {
currentRow <- fullPresenceDFModified[m, ]
currentVariantName <- rownames(currentRow)
samplesVecString <- paste(colnames(currentRow)[currentRow != 0], collapse = ", ")
variantInSamples[m] <- samplesVecString
names(variantInSamples)[m] <- currentVariantName
}
# Change things to a DF merge
variantCountsDF <- data.frame("Number_of_Samples" = variantCounts)
variantInSamplesDF <- data.frame("Samples" = variantInSamples)
# Make sure the dimensions of these match
if (!(identical(dim(variantCountsDF), dim(variantInSamplesDF)))) {
stop("Something is wrong with the variant/sample counting.",
call. = FALSE)
}
# Otherwise, merge them.
variantDataDF <- merge(variantCountsDF, variantInSamplesDF, by = "row.names")
variantDataDF <- variantDataDF %>%
filter(Number_of_Samples >= 2) %>%
arrange(desc(Number_of_Samples)) %>%
column_to_rownames(var = "Row.names") %>%
rownames_to_column("Variation")
# Put warning within app.R to deal with empty table.
# Now pull extra information before displaying table - from Reducing information
#   from sampleVariantsDFList
variantInformationDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2, all = TRUE)},
x = sampleVariantsDFList)
# From variantInformationDF, append information to variantDataDF
variantInformationFullDF <- merge(x = variantDataDF, variantInformationDF,
by = "Variation", all = FALSE)
# Modify the table
variantInformationFinal <- variantInformationFullDF %>%
select(-c(Variation)) %>%
select(Variation_Readable, everything()) %>%
data.table::setnames(old = "Variation_Readable",
new = "Variation")
return(variantInformationFinal)
}
## TEST ##
matchesTest <- FindExactMatches(sampleObjectList = originalSampleObjectList)
## TEST ##
sampleVector <- c("Baldridge_17", "Baldridge_16", "Baldridge_15")
dataSet <- "baldridge_rumspringa"
originalSampleObjectList <- BuildSampleObjects(dataSet = dataSet, sampleVector = sampleVector)
genome_size <- 7383 # For calculation/formatting avg. genome coverage
originalSampleObjectList <- BuildSampleObjects(dataSet = dataSet, sampleVector = sampleVector)
matchesTest <- FindExactMatches(sampleObjectList = originalSampleObjectList)
View(matchesTest)
source('C:/Users/rache/Desktop/Projects/_Baldridge_Lab/VariantViewR/VariantViewR_shiny_app/global.R')
runApp()
source('C:/Users/rache/Desktop/Projects/_Baldridge_Lab/VariantViewR/VariantViewR_shiny_app/global.R')
runApp()
runApp()
## TEST ##
sampleVector <- c("Baldridge_Filtered", "Baldridge_Unfiltered")
dataSet <- "larry_mnv_190206"
originalSampleObjectList <- BuildSampleObjects(dataSet = dataSet, sampleVector = sampleVector)
View(originalSampleObjectList)
matchesTest <- FindExactMatches(sampleObjectList = originalSampleObjectList)
sampleObjectList <- originalSampleObjectList
# Check if any samples have 0 variants and remove.
variantsAreNull <- vector(mode = "logical", length = length(sampleObjectList))
for (i in 1:length(sampleObjectList)) {
variantsAreNull[i]<- is.null(names(sampleObjectList[[i]]@variant_list))
}
selectedSampleObjectList <- sampleObjectList[!variantsAreNull]
selectedSampleObjectList
length(selectedSampleObjectList)
FindExactMatches <- function(sampleObjectList) {
# Check if any samples have 0 variants and remove.
variantsAreNull <- vector(mode = "logical", length = length(sampleObjectList))
for (i in 1:length(sampleObjectList)) {
variantsAreNull[i]<- is.null(names(sampleObjectList[[i]]@variant_list))
}
selectedSampleObjectList <- sampleObjectList[!variantsAreNull]
if (length(selectedSampleObjectList) == 0) {
stop("No variants are detected in the selected samples",
call. = FALSE)
}
#----- Exact Matching (Position & Variant) -----#
# For all the variants between the selected samples, make a table showing which
#   samples they are in.
sampleVariantsDFList <- vector(mode = "list", length = length(selectedSampleObjectList))
sampleVariantsPresenceList <- vector(mode = "list", length = length(selectedSampleObjectList))
# pull extra info here and stick into currentSampleDF
for (k in 1:length(selectedSampleObjectList)) {
# Get current sample information
currentSample <- selectedSampleObjectList[[k]]
currentSampleName <- currentSample@sample_name
# Build concatenated data frame from all the variants' variant_df slots
#   get current Variants, put in list
currentVariantList <- currentSample@variant_list
#   pull out each variant's variant_df, put in list
currentVariantDFList <- map(.x = seq(1:length(currentVariantList)),
.f = function(idx) currentVariantList[[idx]]@variant_df)
#   reduce the list into one big df - (all variants' info for one sample only)
combinedVariantDFs <- Reduce(f = function(df1, df2) {rbind(x = df1, y = df2)},
x = currentVariantDFList)
#   store the samples variants info in sampleVariantsDFList to be reduced later
sampleVariantsDFList[[k]] <- combinedVariantDFs
# Build variantPresenceDF that will be used for searching for common variants
variantPresenceDF <- data.frame(names(currentSample@variant_list), 1)
colnames(variantPresenceDF) <- c("variants", currentSampleName)
sampleVariantsPresenceList[[k]] <- variantPresenceDF
}
# Merge the presence data frames together, convert NA's to 0's
fullPresenceDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2,
by = "variants", all = TRUE)},
x = sampleVariantsPresenceList)
fullPresenceDF[is.na(fullPresenceDF)] <- 0
# remove extra columns before attempting rowSums
# What are the counts for each variant?
fullPresenceDFModified <- column_to_rownames(fullPresenceDF, var = "variants")
variantCounts <- rowSums(fullPresenceDFModified)
# Which samples do you find each variant in?
variantInSamples <- vector(mode = "character", length = nrow(fullPresenceDFModified))
for (m in 1:nrow(fullPresenceDFModified)) {
currentRow <- fullPresenceDFModified[m, ]
currentVariantName <- rownames(currentRow)
samplesVecString <- paste(colnames(currentRow)[currentRow != 0], collapse = ", ")
variantInSamples[m] <- samplesVecString
names(variantInSamples)[m] <- currentVariantName
}
# Change things to a DF merge
variantCountsDF <- data.frame("Number_of_Samples" = variantCounts)
variantInSamplesDF <- data.frame("Samples" = variantInSamples)
# Make sure the dimensions of these match
if (!(identical(dim(variantCountsDF), dim(variantInSamplesDF)))) {
stop("Something is wrong with the variant/sample counting.",
call. = FALSE)
}
# Otherwise, merge them.
variantDataDF <- merge(variantCountsDF, variantInSamplesDF, by = "row.names")
variantDataDF <- variantDataDF %>%
filter(Number_of_Samples >= 2) %>%
arrange(desc(Number_of_Samples)) %>%
column_to_rownames(var = "Row.names") %>%
rownames_to_column("Variation")
# Put warning within app.R to deal with empty table.
# Now pull extra information before displaying table - from Reducing information
#   from sampleVariantsDFList
variantInformationDF <- Reduce(f = function(df1, df2) {merge(x = df1, y = df2, all = TRUE)},
x = sampleVariantsDFList)
# From variantInformationDF, append information to variantDataDF
variantInformationFullDF <- merge(x = variantDataDF, variantInformationDF,
by = "Variation", all = FALSE)
# Modify the table
variantInformationFinal <- variantInformationFullDF %>%
select(-c(Variation)) %>%
select(Variation_Readable, everything()) %>%
data.table::setnames(old = "Variation_Readable",
new = "Variation")
return(variantInformationFinal)
}
matchesTest <- FindExactMatches(sampleObjectList = originalSampleObjectList)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source('C:/Users/rache/Desktop/Projects/_Baldridge_Lab/VariantViewR/VariantViewR_shiny_app/global.R')
runApp()
runApp()
18 * 4
# Annotate_Mutations.R
# For each VCF file, annotate the reference and alternative mutations.
load("Mod_CR6_ORF_Information.RData")
library("dplyr")
library("stringr")
# Find correct files, store and loop
rawVCFFilePath <- "../larry_mnv_190306/variants"
rawVCFFiles <- list.files(rawVCFFilePath, pattern = ".vcf", full.names = TRUE)
annotatedVCFDirectory <- file.path(rawVCFFilePath, "annotated_variants")
dir.create(annotatedVCFDirectory)
for (j in 1:length(rawVCFFiles)) {
variantSample <- rawVCFFiles[j]
variantSampleName <- str_remove(string = basename(variantSample),
pattern = "\\.vcf")
# for current sample set, open each VCF file, add column for reference and mutant allele
# if the ref and/or alt is an INDEL, just mark columns as INDEL
vcfFile <- tryCatch({ # in case there are no variants in the VCF file
read.delim(variantSample,
comment.char = "#", # ignore VCF header lines
header = FALSE,
colClasses = "character") # suppress conversion of columns
},
error = function(e) {
# return an empty data frame
data.frame("Reference Genome" = character(0),
"Position" = character(0),
"ID" = character(0),
"Reference" = character(0),
"Alternative" = character(0),
"Quality"= character(0),
"Filter" = character(0),
"Info" = character(0),
"Format" = character(0),
"Values" = character(0))
})
vcfHeaders <- c("Reference Genome", "Position",
"ID", "Reference", "Alternative",
"Quality", "Filter", "Info", "Format", "Values")
names(vcfFile) <- vcfHeaders
# If VCF file isn't empty, add a column for Reference Protein, Alternative Protein,
#   and Mutation Type
# set orf ranges
orf1Range <- seq(from = 6, to = 5069)
orf2Range <- seq(from = 5070, to = 6681)
orf3Range <- seq(from = 6681, to = 7307)
if (nrow(vcfFile) != 0) {
vcfFileAnnotated <- cbind(vcfFile,
"Reference Codon" = NA, "Reference Protein" = NA,
"Mutant Codon" = NA, "Mutant Protein" = NA,
"Mutation Type" = NA)
# loop over the rows and populate the new columns
for (i in 1:nrow(vcfFileAnnotated)) {
currentRow <- vcfFileAnnotated[i, ]
if (nchar(currentRow$Reference) > 1 | nchar(currentRow$Alternative) > 1) {
vcfFileAnnotated[i, "Mutation Type"] <- "INDEL"
next()
} else {
mutantAllele <- currentRow$Alternative
mutantPosition <- currentRow$Position
currentCodonLUT <- NULL
currentCodonClassList <- NULL
if (mutantPosition %in% orf1Range) {
currentCodonLUT <- orf1CodonLUT
currentCodonClassList <- orf1CodonClassList
} else if (mutantPosition %in% orf2Range) {
currentCodonLUT <- orf2CodonLUT
currentCodonClassList <- orf2CodonClassList
} else if (mutantPosition %in% orf3Range) {
currentCodonLUT <- orf3CodonLUT
currentCodonClassList <- orf3CodonClassList
}
# if mutant position doesn't align to any orf, move on to next mutation
if (is.null(currentCodonClassList)) {
currentRow$`Mutation Type` <- "non-coding"
isNonCodingMutation <- TRUE
next()
}
# determine identity of ref protein
referenceCodonName <- currentCodonLUT[as.character(mutantPosition)]
referenceCodon <- currentCodonClassList[[referenceCodonName]]
referenceCodonString <- paste(referenceCodon@sequence_vector, collapse = "")
referenceProtein <- Biostrings::GENETIC_CODE[[referenceCodonString]]
referenceProteinFull <- aminoAcidCode[[referenceProtein]]
vcfFileAnnotated[i, "Reference Protein"] <- referenceProteinFull
vcfFileAnnotated[i, "Reference Codon"] <- referenceCodonString
# determine identity of mutant protein from ref codon
mutantCodon <- referenceCodon@sequence_vector
mutantCodon[as.character(mutantPosition)] <- mutantAllele
mutantCodonString <- paste(mutantCodon, collapse = "")
mutantProtein <- Biostrings::GENETIC_CODE[[mutantCodonString]]
mutantProteinFull <- aminoAcidCode[[mutantProtein]]
vcfFileAnnotated[i, "Mutant Protein"] <- mutantProteinFull
vcfFileAnnotated[i, "Mutant Codon"] <- mutantCodonString
# Determine mutation type
if (referenceProtein == mutantProtein) {
# synonymous
vcfFileAnnotated[i, "Mutation Type"] <- "synonymous"
} else {
if (mutantProtein == "*") {
# nonsense
vcfFileAnnotated[i, "Mutation Type"] <- "nonsense"
} else {
# missense
vcfFileAnnotated[i, "Mutation Type"] <- "missense"
}
}
}
}
# write the file out
write.table(x = vcfFileAnnotated,
file = paste(annotatedVCFDirectory, "/",
variantSampleName, "_annotated.txt",
sep = ""),
append = FALSE, quote = FALSE, sep = "\t", row.names = FALSE)
} else { # empty file
write.table(x = vcfFile,
file = paste(annotatedVCFDirectory, "/",
variantSampleName, "_annotated.txt",
sep = ""),
append = FALSE, quote = FALSE, sep = "\t", row.names = FALSE)
}
}
shiny::runApp()
runApp()
previousMtxSize <- 0 # for determining when to re-paint the coverage plot
shiny::runApp()
